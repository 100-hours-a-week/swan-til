## 무엇을 배웠나요

Javascript 응용 지식<br>
굴직굴직한 녀석들만 정리해야지

### 함수형 패러다임

- `일급 함수`<br>
해당 환경에서 함수를 어떠한 취급을 할지에 관한 부분입니다.<br>
일급 시민 취급을 한다는건 변수로도 다뤄질 수 있다고 이해하면 좋습니다.<br>
JS는 다른 모던 PL들처럼 함수를 변수로도 다룰 수 있습니다. 다르게 말해 함수를 다른 함수의 인자로 또는 반환값으로 사용할 수 있다는 것입니다.<br>
이를 통해 순수 함수, 익명 함수 등을 언어 레벨에서부터 잘 지원받아 효과적으로 사용할 수 있습니다.<br>
<br>

- `순수 함수`<br>
동일한 입력을 받을 때 언제나 같은 결과를 반환하는 함수를 이르는 말입니다. (입력값에만 의존)<br>
이러한 순수 함수의 장점으로는 **사이드 이펙트**가 없고 **결과를 예상할 수 있다는 점입니다.**<br> 그리고 불변성을 지킬 수 있고 이러한 장점들은 병렬환경에서도 좋은 결과를 기대할 수 있습니다.<br>
> 순수 함수는 입력값에만 의존을 하는데 상황에 따라 입력값 외의 값에 의존해야만하는 상황이 옵니다. 즉 모든 상황에서 순수 함수를 추구할 순 없습니다.
<br>

- `고차 함수`<br>
함수를 인자로 받거나, 함수를 반환값으로 가지는 함수를 말합니다.<br>
언어에서 지원하는 `map`, `filter` 같은 함수들도 그 일종입니다.<br>
그 자체로 함수를 인자로 받고 반환하는 고차 함수는 함수의 재사용성을 장려합니다.
<br>

- `익명 함수`<br>
보통 일시적으로 사용될 함수를 다룰 때 사용하며 익명함수는 함수의 이름이 없으니 변수에 담아 관리합니다. 콜백함수 형태에서 자주 볼 수 있습니다.
<br>

- `즉시 실행 함수`<br>
정의와 동시에 한 번 실행하는 함수입니다. 어느 상황에 잘 사용될지 감이 안오네요.<br>

### 모듈 시스템

- `CJS (Common Javascript)`<br>
기존의 전통적인 방식의 모듈 시스템입니다. 동기적으로 동작하며 require와 module.exports, exports 를 통해 동작합니다.
<br>

- `ESM (Ecmascript Module)`<br>
es6 이상 버전의 모듈 개념을 통해 동작하는 시스템이비다. 비동기적으로 동작하며 웹브라우저와의 상성이 좋습니다. import, export, export default 를 통해서 동작합니다.<br>

최신 프로젝트라면 ESM 사용을 고려하는게 좋다는 분위기다.<br>

### 블로킹과 동기 이야기<br>
사실 블로킹, 동기는 현재 고려 중인 맥락이 블로킹이냐 논블로킹이냐 동기이냐 비동기이냐를 따지기 이전에 하드웨어의 멀티프로세서나 멀티 쓰레딩 또는 가상머신이나 런타임에서 동시성, 병렬성을 어떻게 지원해주느냐에 따라서 고려할 부분이 많이 있습니다. 이러한 부분을 명확히 하지 않은채 블로킹, 동기를 이해하려하면 결국엔 장해물을 만나게 될 것입니다.<br>

이 글에선 하드웨어적으론 하나의 프로세서에서 2개 이상의 쓰레드를 제공하며 JS 언어와 NodeJS 를 전제로합니다. JS언어를 사용하는만큼 싱글 스레드를 지원하며 이벤트 루프를 통해 동시적으로 처리를 제공합니다. (이벤트 루프에 대한 자세한 설명은 다음에 하겠습니다.)<br>

- `블로킹과 논블로킹`<br>
블로킹은 제어권을 넘겨준 이후 자원(CPU)의 점유 여부를 따집니다.<br>
기존 메소드(A)에서 다른 메소드(B)를 호출할 때 A는 B가 끝날 때까지 기다릴 수 있습니다. 그렇게 될 경우 A는 기다리는 동안 CPU 자원을 점유(낭비) 하게 됩니다. 이러한 방식을 **블로킹**이라 합니다. 그렇다면 **논블로킹**은 다음과 같이 설명할 수 있습니다. 다른 메소드를 호출한 후 다른 메소드의 완료와 상관없이 다른 작업을 처리하는 것입니다. 기다리지 않고 다른 작업을 할 수 있기에 성능적으로 나을 수 있겠습니다.<br>

> 여기서 말하는 작업이란 A 메소드의 B 메소드 호출부 이하의 작업이라기보단 C 메소드 같은 이미 실행 중인 다른 작업들입니다. 그래서 A 메소드에서 블로킹 중일땐 B 메소드의 종료까지 CPU를 점유하고 이 점유하는 사이엔 C 메소드의 작업은 CPU를 얻지 못하고 대기합니다. 하지만 논블로킹 방식에선 B 메소드의 완료까지 CPU를 점유하지 않으니 그 사이에 C 메소드의 작업이 시작될 수 있습니다. 전체적인 처리 성능에 좋은 영향을 줄 수 있습니다.<br>
이 말만 듣고보면 어느 상황에서나 논블로킹이 효율적일 것 같은데 논블로킹을 구현하려면 시스템의 복잡성이 높아지고 디버깅 시 어려움이 있습니다. 아직 이에 대한 제대로된 경험이 없어 이 부분의 설명이 어렵네요.

<br>

- `동기와 비동기`<br>
동기, 비동기는 작업들의 순서에 관련된 개념입니다.<br>
기존 메소드(A)에서 다른 메소드(B)를 호출할 때 A는 B가 끝날 때까지 기다릴 수 있습니다. (블로킹과 헷갈리는 요소) 이렇게 기다린 다음 A의 나머지 작업을 처리합니다. 이를 통해 순서를 보장할 수 있습니다. 이런 방식을 **동기**적인 방식이라 합니다. 그렇다면 **비동기**적인 방식은 다음과 같이 설명할 수 있습니다. <br>
다른 메소드를 호출하고 그 결과를 기다리지 않고 다른 작업을 처리하는 것입니다. 그로인해 순서를 보장받기는 힘듭니다. 처리과정을 순서도로 나타냈을 때 뒤죽박죽일 수 있다는겁니다. 현실적으로 볼땐 디버깅하기가 동기에 비해 무척 까다로워집니다.<br>

글에서는 블로킹과 동기 개념을 따로 설명했지만 사실 이 개념은 **한 가지 맥락을 어떠한 관점에서 바라볼 것인가**에 따라 접근할 수 있는 부분이었습니다.
자원 점유의 경우 블로킹, 순서의 경우엔 동기 이렇게 볼 수 있습니다.<br>

**예시를 통해 분명히 해보겠습니다.**<br>
각 특성부터 접근한것과 달리 이번엔 한 가지 맥락을 두고 이 맥락에서 자원 점유, 순서 관점에서 각각 어떠한 특성을 가지는지 보겠습니다.<br><br>

> 1 . 파일 전체를 읽어 콘솔에 출력합니다.
```
const fs = require('fs');

const data = fs.readFileSync('/path/to/file.txt', 'utf8');
console.log(data); // 파일이 완전히 읽힌 후에 출력됨
// 파일 읽기가 끝날 때까지 다른 작업을 수행하지 않음
```
<br>
현재 코드는 파일을 완전히 읽을 때까지 작업을 기다리게 됩니다. 이후 작업이 이미 다 불러온 파일을 대상으로 후처리하는 작업이기 때문입니다. 순서가 지켜져야만하기에<br>
순서 관점에선 **동기적**이다 볼 수 있습니다. 그리고 별도의 비동기 호출을 하지 않았기에 콜스택에 추가되어 파일을 불러올때까지 자원을 점유할 것입니다. 자원 점유의 관점에서 **블로킹**이다 볼 수 있습니다.<br><br>

> 2. 알람을 보내고 추가적인 작업을 합니다.
```
function sendAlarm() {
    console.log("Sending alarm...");

    // 비동기 논블로킹 방식으로 3초 후에 알람 전송
    setTimeout(() => {
        console.log("Alarm sent!");
    }, 3000);
}

// 알람 전송을 비동기적으로 시작
sendAlarm();

// 다른 작업 실행
console.log("Doing other tasks while waiting for the alarm to be sent...");

for (let i = 1; i <= 3; i++) {
    console.log(`task ${i}`);
}

// 결과:
// "Sending alarm..."
// "Doing other tasks while waiting for the alarm to be sent..."
// "task 1"
// "task 2"
// "task 3"
// (3초 후)
// "Alarm sent!"
```
<br>
알람 전송을 완료하기 전에 다른 작업을 수행할 수 있었습니다. CPU 점유는 일어나지 않았다 판단하여 자원 점유 관점에선 **논블로킹**, 순서 관점에선 먼저 수행된 함수 상관 없이 독립적인 결과를 보여 **비동기**라고 할 수 있습니다.<br>

> 그외 동기 논블로킹, 비동기 블로킹은 JS환경에서 구현하기가 다소 억지스러웠습니다. 특히 비동기 블로킹은 정말 보기 힘들다고 합니다. 둘 다 말만 풀어보자면 `동기 논블로킹`은 순서를 보장함에도 자원을 점유하지 않으며 `비동기 블로킹`은 순서를 보장하지 않으면서 자원은 또 점유를 하는 방식입니다. 확실히 순서 보장 없이 자유롭고 독립적으로 실행하는 반면 자원은 독점을 해버리는 상황이니 `비동기 블로킹`은 모순적이고 비효율적으로 보입니다.
<br>
굳이 동기 논블로킹 방식을 JS에서 묘사해보자면 await 을 이용한 순서보장 방식이 있을 수 있을 것 같다.

```
function doTask(taskNumber) {
    console.log(`Starting task ${taskNumber}...`);
}

// 동기적으로 순서대로 실행하지만, 콜스택을 막지 않도록 하는 비동기 논블로킹 구조
async function executeTasks() {
    for (let i = 1; i <= 5; i++) {
        await new Promise((resolve) => {
            setTimeout(() => {
                doTask(i);
                resolve();
            }, 0); // 비동기로 처리
        });
    }
    console.log("All tasks completed!");
}

// 함수 실행
executeTasks();
console.log("Main thread continues...");
```

### JS의 비동기 관련 개념, 키워드

- `콜백 함수`
다른 함수의 인자로 넘겨져 내부에서 호출되는 함수입니다. 이벤트 루프 구조에선 콜백큐에 저장이 됩니다.
콜백 함수라 하여 다 비동기는 아닙니다. <br>
    - `동기적 콜백`: 다른 함수의 실행이 완료된 이후 바로 호출되는 콜백 함수
    ```
    const numbers = [1, 2, 3];
    numbers.forEach((num) => {
        console.log(num); // 각 숫자가 순차적으로 출력됩니다.
    });
    ```
    <br>

    - `비동기적 콜백`: 특정 작업이 완료된 후 호출 되는 콜백 함수
    ```
    setTimeout(() => {
        console.log('This runs after 1 second');
    }, 1000);
    ```
    <br>

- `Promise`<br>
비동기 논블로킹 결과를 처리하는 방식 중 하나. Promise 는 비동기 논블로킹 결과를 래핑하여 다루는 객체. 비동기 연산을 도와줍니다.<br>
promise 내부에서 resolve, reject 를 통해 결과와 상태를 다룰 수 있습니다.<br>
promise 완료 후 작업은 then, 예외 발생 시 catch 를 통해서 다룰 수 있습니다.<br><br>
> 콜백 함수와는 뭐가 다른걸까.
가독성은 좀 더 나은것 같은데 콜백 지옥 같은 패턴은 Promise 만으론 완벽히 해결하기가 힘들 것 같다. 일반적인 콜백 지옥은 어느 정도 잘 해소할 수 있었습니다.
예외 시의 처리도 다룰 수 있다는 점이 좋은 것 같다. finally 도!
<br>

- `async / await`<br>
    - `async` : 반환형을 Promise 로 보장하는 함수 키워드<br><br>
    - `await` : Promise 완료 동안 다른 작업을 차단하지 않고 기다립니다. (원리가 신기)<br>
    await 은 정말 좋은 아이이다. 이 아이덕분에 읽기 힘든 비동기 코드를 동기적으로 나타낼 수 있습니다. 멈추지 않고 쭉쭉 실행하는 비동기 논블로킹 환경에서 사이드 이펙트 없이 기다리는 개념을 추가해 가독성을 향상시킨다니 정말 엄청나다..!
<br>

### JS 엔진<br>
- `스택, 힙`<br>
메모리 구조에서 언급되는 스택, 힙이 맞습니다. 이후에 나올 실행 컨텍스트와 렉시컬 환경이 각각 스택, 힙을 따릅니다. 
<br>

- `실행 컨텍스트`<br>
코드 호출 시의 환경 정보가 스택에 적재됩니다. 각 호출마다 새롭게 실행 컨텍스트가 생성됩니다. 실행이 끝난 경우엔 pop 됩니다.
<br>

- `렉시컬 환경`<br>
블록 수준의 변수, 함수가 저장됩니다. (전역 시점의 변수는 전역 렉시컬 환경에 저장된다는 것 같은데 좀 더 알아봐야겠네요.)
<br>

- `생성 단계`<br>
코드의 변수, 함수가 선언됩니다. 렉시컬 환경에 생성됩니다.<br>
이 때 함수는 함수 선언 시점의 정보가 렉시컬 환경에 저장됩니다.
<br>

- `실행 단계`<br>
실제 코드가 실행되며 초기화를 합니다. 존재하지 않는 변수에 접근 시 이전 실행 컨텍스트에 차례로 접근해 찾아냅니다. 이를 스코프 체인이라 부릅니다.
<br>

- `호이스팅`<br>
실행 전 모든 변수를 렉시컬 환경에 생성합니다.<br>
var 는 undefined 로 초기화하며 let, const는 초기화 없이 선언만하며 접근 시 에러가 발생합니다.  TDZ 상태라 합니다. 잠정 죽은 상태
<br>

- `렉시컬 스코프`<br>
함수 호출 시 호출될 때의 환경이 아닌 렉시컬 환경의 정보(선언 시점)를 사용한다는 원리입니다.
<br>

- `스코프 체인`<br>
현 실행 컨텍스트에서 발견할 수 없는 변수는 이전 실행 컨텍스트를 순회하며 찾습니다. 없을 경우 전역 컨텍스트에 변수를 선언하고 할당합니다.
<br>

**실행 과정**<br>
1. `코드 읽기`<br>
    코드를 읽고 의미있는 단위(토큰)으로 나눕니다.<br><br>
2. `구문 분석`<br>
    토큰을 바탕으로 트리를 만듭니다.<br><br>
3. `호이스팅`<br>
    변수나 함수를 스코프 최상단에 위치해 늘 찾을 수 있게 합니다.<br><br>
4. `렉시컬 스코프 결정`<br>
    함수의 호출 위치에 상관없이 선언 시점의 정보를 사용하게 합니다.<br><br>
5. `바이트 코드 생성`<br>
    트리 구조를 바탕으로 저수준언어로 바꿉니다. 이 코드는 자바스크립트 가상머신에서 실행됩니다.<br><br>
6. `실행`<br>
    변수에 값이 할당되고, 함수가 호출됩니다.<br><br>
7. `스코프 체인`<br>
    실행 중인 환경에서 변수를 찾을 수 없을 때 현재 스코프에서 상위 스코프로 이동해 탐색합니다.<br><br>
