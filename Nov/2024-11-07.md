## 현대 컴퓨터 언어에서의 멀티 쓰레드를 통한 비동기, 논블로킹 구현에 관한 고찰
기존의 동기적, 블로킹 방식의 코드는 성능적 부하를 일으킬 수 있었습니다.<br>
<br>
하나의 쓰레드에서 무거운 작업을 다 처리하려면 전체적인 소요시간이 많이 듭니다.<br>
이러한 상황에선 새로운 쓰레드를 생성해 무거운 작업들을 위임하는 것입니다.<br>
<br>
이렇게 새로운 쓰레드를 활용한 방식은 기존 코드에서 적합한 맥락이 있고 적합하지 않은 맥락이 있습니다.<br>
<br>
적합한 맥락으로는 푸시 알림 전송이 있습니다.<br>
게시글을 생성하는 상황에서 실제 생성 과정 이전에 생성에 대한 푸시 알림을 전송할 수 있습니다.<br>
이때 푸시 알림과 푸시 알림 이후의 로직 사이엔 연관성이 없습니다. 푸시 알림이 실패한다고 해서 이후 로직이 실패해야할 이유는 없습니다. <br>
이런 상황에선 푸시 알림을 다른 쓰레드로 실행시키고 실제 게시글 생성 과정을 진행하는 것입니다.<br>
멀티 쓰레딩을 통해 병렬적 진행으로 평균 응답속도의 개선을 기대할 수 있습니다.<br>
<br>
적합하지 않은 맥락으로는 파일 입력이 있습니다.<br>
파일을 입력 받고 DB에 저장하는 경우 파일을 다 입력받기 전엔 DB에 저장할 수가 없습니다.<br>
두 작업 사이엔 연관성이 있습니다.<br>
이런 상황에선 입력 작업을 다른 쓰레드로 돌린다해도 이 작업이 끝날때까지 기다려야합니다.<br>
JS에선 async, await으로 동작한다고 알고있습니다. 그리고 콜백으로도 파일 입력이 끝난 이후 동작해야할 로직을 지정할 수도 있습니다.<br>
<br>

## 개인적인 오해
멀티 쓰레드로 작업들을 병렬적으로 실행하면 비로 대기를 하며 쓰레드를 점유하는 경우가 있지만<br>
쓰레드의 선점형 스케쥴링에 의해 정상적으로 도작할 것이라 생각했습니다.<br>
이 때 말하는 블로킹은 대기를 하며 쓰레드를 점유하는 것도 포함하는 것처럼 들립니다.<br>
그렇기에 콜백이나 promise, async, await 방식은 대기 쓰레드를 두는 것이 아닌 콜백 함수들을 따로 저장해둬 트리거 작업이 종료되면 실행하도록 구현하는 것 같습니다.<br> 
대기 쓰레드를 두는게 아닌 콜백 예약 함수들을 따로 저장하여 관리하는 것입니다. pub-sub 방식과도 유사해 보입니다.<br> 

## 정리
정리하자면 현대 컴퓨터 언어에선 멀티 쓰레드를 통한 병렬작업을 통해 비동기 논블로킹을 구현한다라고 이해하기 보단 연관성이 있는 작업들을 나누어 선행되는 작업을 쓰레드 단에서 기다리게 하기보단 의존을 하는 후속 콜백 함수들을 메모리 수준에서 저장을 한 뒤 트리거 함수가 성공하면 후속 콜백 함수를 실행한다는 개념 같습니다.<br>  즉 대기 쓰레드가 없습니다.<br>  polling 과 pub-sub 의 차이와도 유사하게 들려 기분이 좋네요. (지금껏 공부했던 내용들이 서로 맛물려가는 기분이 들어 살짝 보람이 있습니다. 야호!)




